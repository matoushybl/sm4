\section{Embedded Rust}
\label{sec:embedded_rust}
Embedded Rust is enabled by two crate-level attributes - \textbf{no\_main} and \textbf{no\_std}.
The \textbf{no\_main} attribute indicates, that the compiler will not emit a main symbol automatically, but instead expects the crate to define it itself\cite{noauthor_crates_2021}.
The \textbf{no\_std} attribute on the other hand indicates that the final program will not link against the std crate (containing functions usable with operating systems and heap allocation), but instead will link against the core crate, which contains only those parts of the standard library that are platform agnostic.
The core crate includes for example language primitives, such as floats, slices and support for atomic instructions.
Rust program with the \textbf{no\_std} attribute and therefore linking to core library can be used for bootstrapping code like bootloaders, firmware or kernels\cite{rust_embedded_devices_wg_introduction_2021}.

Using the \textbf{no\_main} requires the programmer to write their own program entry point and some other functions, such as the reset handler and panic handlers, an example of such low-level project bring-up can be seen in~\cite{munns_zero_2019}.
That can be quite hard and is usually platform dependent.
Thankfully, for the supported \acs{mcu}s this is already pre-implemented by processor low-level access crates and their startup and runtime crates.

We've mentioned that developing \textbf{no\_std} does not by default use heap allocation.
Heap allocation can however be added to \textbf{no\_std} programs by implementing a custom allocator such as the \textbf{alloc-cortex-m} crate\cite{rust_embedded_devices_wg_rust-embeddedalloc-cortex-m_2021}, that implements an allocator for Cortex-M \acs{mcu}s.
Using heap allocation, it is possible to use structures like \textbf{vec} and \textbf{Box<T>}\cite{noauthor_alloc_nodate}.
It also seems to be possible to run a subset of the Rust std library directly on a \acs{mcu}\cite{hutt_using_nodate}, but this approach is still in the early stages of development.

\subsection{Platform Support}
\label{subsec:platform_support}
In order to compile Rust programs for specific \acs{mcu} core, it is required that a target support for it is first available in LLVM and second that a target for it exists within the Rust ecosystem (existence of a target means, that the rust compiler and other tools and can be built for the target).
Rust targets are also split into tiers differentiating different amounts of support from the Rust teams, where majority of the embedded targets are in Tier 2, meaning that the compilation of the tools must succeed for every change in the compiler, but automated tests of the builds are not guaranteed to run.
As of now, there is support for different \acs{arm} architectures, such as aarch64, armv7, armv6, thumbv8, thumbv7, thumbv6 (both with hardware FPU and without) etc\cite{noauthor_platform_nodate}.
Apart from \acs{arm} support, there is also support for \acs{risc}-V targets, Tier 3 also contains support for AVR\cite{noauthor_platform_nodate, rahul_how_nodate}, MSP430.
There also seems to be some effort into bringing the Xtensa architecture (ESP8266 and ESP32)\cite{mabin_mabezdevxtensa-rust-quickstart_2021} into the Rust ecosystem as the work of supporting the architecture in LLVM seems to be done.

\subsection{Embedded Working Group}
\label{subsec:embedded_wg}
Embedded Rust is one of the official goals of the Rust Language project, and the development of Rust for embedded devices is governed by the Embedded Devices Working Group\cite{noauthor_embedded_nodate}.
Apart from target maintenance, the working group is directly responsible for creating and maintaining documentation - such as the Embedded Rust book\cite{rust_embedded_devices_wg_introduction_2021}, the Discovery book\cite{rust_embedded_devices_wg_introduction_nodate} and the Embedonomicon book\cite{rust_embedded_devices_wg_preface_nodate} and is also responsible for developing several of the critical tools and libraries - such as \textbf{svd2rust}, \textbf{embedded-hal} or \textbf{embedded-dma}.

The working group also governs the work on low level \acs{mcu} core access crates and minimal runtimes for these cores such as the \textbf{cortex-m} and \textbf{cortex-m-rt} or \textbf{risc-v} and \textbf{riscv-rt}.

\subsection{Register Access}
\label{subsec:register_access}
Peripheral and core register access is one of the most vital operations on embedded systems.
Generally, in C/C++ this is done either by operating on a pointer to an integer value or by modifying a struct that contains the configuration.
In embedded Rust, there are two approaches to this problem

The first approach is the \textbf{svd2rust}\cite{rust_embedded_devices_wg_rust-embeddedsvd2rust_2021} tool.
This tool uses the manufacturer provided \acs{svd} files, that describe registers and their bits and converts them into a Rust \acs{api}.
There are several advantages to this approach - no code needs to be written manually, the resulting register access is compile time safe, allows for named bit settings instead of non-descriptive setting to logical 1 or zero and when there is ambiguity for example in integer size, it enforces adding the unsafe keyword, marking that the code should be thoroughly reviewed.
An example of setting a register values using this approach can be seen in the following Listing~\ref{lst:svd2rust}, where we are configuring channel of an advanced control timer.
The disadvantage of this approach is that given the size of the \acs{svd} files, and number of \acs{mcu}s, the compilation is quite long and given the resulting \acs{api} complexity, the contemporary \acs{svd}s have problems resolving it for autocomplete.
This approach is prevalent with the majority of the \acs{pac}s (\acl{pac}s), for example with the \textbf{stm32-rs} crate\cite{noauthor_stm32-rsstm32-rs_2021}.

\begin{lstlisting}[caption={Using svd2rust generated API for register access.},label=lst:svd2rust]
timer.ccmr2_output().modify(|_, w| {
    w.cc4s()
        .output() // channel 4 as output
        .oc4fe()
        .set_bit() // enable fast output
        .oc4pe()
        .set_bit() // enable preloading
        .oc4m()
        .toggle() // set mode (3bit wide register part)
});
\end{lstlisting}

Another and more lightweight approach is utilization of RAL (Register Access Layer) crates, for example the \textbf{stm32ral}\cite{greig_adamgreigstm32ral_2021}.
This approach also parsed the \acs{svd} files, but generates simpler structures, and \acs{api}.
An example of using this approach can be seen in the Listing~\ref{lst:ral}.
\begin{lstlisting}[caption={Using RAL API for register access\cite{greig_adamgreigstm32ral_2021}.},label=lst:ral]
modify_reg!(rcc, rcc, AHB1ENR, GPIOAEN: Enabled);
modify_reg!(gpio, gpioa, MODER, MODER1: Input, MODER2: Output, MODER3: Input);
\end{lstlisting}

\subsection{embedded-hal}
\label{subsec:embedded_hal}
The \textbf{embedded-hal} project\cite{rust_embedded_devices_wg_rust-embeddedembedded-hal_2021} is one of the projects developed by the Embedded Devices Working Group.
Its aim is to provide a \acs{hal} (\acl{hal}) abstract enough that device drivers using it may be shared not only between different \acs{mcu}s but also different platforms (\acs{mcu} and Embedded Linux).
This is achieved by utilizing traits, described earlier in the Section~\ref{subsec:traits}.
An example of such device driver developed using the traits available in the \textbf{embedded-hal} can be seen in the Listing~\ref{lst:hal_usage}.
As can be seen in the Listing, the driver will work with any type that implements the \textbf{WriteRead} trait.
Currently, the \textbf{embedded-hal} defines traits for common embedded functionality (such as \acs{gpio}, \acs{adc}) and buses (I\textsuperscript{2}C, \acs{spi}), but only their blocking variants.

\begin{lstlisting}[caption={Example of an device driver utilizing embedded-hal traits\cite{rust_embedded_devices_wg_rust-embeddedembedded-hal_2021}.},label=lst:hal_usage]
use embedded_hal::blocking::i2c::{TenBitAddress, WriteRead};
const ADDR: u16  = 0x158;
const TEMP_REGISTER: u8 = 0x1;
pub struct TemperatureSensorDriver<I2C> {
    i2c: I2C,
}

impl<I2C, E> TemperatureSensorDriver<I2C>
where
    I2C: WriteRead<TenBitAddress, Error = E>,
{
    pub fn read_temperature(&mut self) -> Result<u8, E> {
        let mut temp = [0];
        self.i2c.write_read(
                ADDR,
                &[TEMP_REGISTER],
                &mut temp
            )
            .and(Ok(temp[0]))
    }
}
\end{lstlisting}

The traits from the \textbf{embedded-hal} are implemented by device \acs{hal}s, such as the \textbf{stm32f4xx-hal}\cite{noauthor_stm32-rsstm32f4xx-hal_2021}, which implements the provided traits for the peripherals of the STM32F4xx \acs{mcu}s.

A crate similar to the \textbf{embedded-hal} is the \textbf{embedded-dma} defining traits for unified \acs{dma} access, so that development of unified device drivers utilizing \acs{dma} is possible.
DMA itself is not that easy problem when aiming for Rust's memory safety\cite{aparicio_memory_nodate}, but a lot of work has been done on its support and perfecting it for safety.

\subsection{Mutable Shared State}
\label{subsec:mut_shared_state}
The Rust programming considers mutable static variables unsafe as they may cause data races in concurrency\cite{noauthor_static_nodate}.
This approach is valid, but causes ergonomics problems with embedded programs where storing data in static variables is used for interchanging data between interrupts and blocking code.
In order to write correct, data race free code, the shared state needs to be at least wrapped in a mutex, that will synchronize access to the shared resource, this however is not enough as the borrow checker will object with invalid access to a shared resource.
Also, when using mutex on embedded systems, the block holding the lock need to be wrapped in a critical section, otherwise the lock would never be freed.
The situation get more complicated with different interrupt priorities.
An overview of ways of solving this problem can be found in an excellent blogpost by one of the members of the Embedded Devices Working group here\cite{egger_look_nodate}.

We decided to use the \acs{rtic} (\acl{rtic}) framework\cite{noauthor_preface_nodate} as a solution to this problem as according to us, the approach is very well thought out.
The framework aims to solve the problem by providing a \acs{dsl} (\acl{dsl}) based on Rust's procedural macros for concurrency on embedded systems.
In short, the \acs{rtic} framework lets the user define shared resources and allows different tasks (either software tasks, or interrupt triggered) to access those resources in a safe way, removing boilerplate code needed for shared resource handling.
Imagine, that there are two interrupt triggered tasks with different priority wanting to access a shared resource.
The high priority task can easily access the resource without need for any explicit locking as it has privilege to do so, given its priority.
On the other hand, the lower priority task needs to perform locking in order to access the shared resource, to avoid the resource being accessed temporarily by the higher resource task, which could lead to a data race.
This behavior is compile-time enforced and checked bringing another level of safety and security to embedded systems.
Apart from providing safe access to shared resources, this framework also contains a simple scheduler for timed tasks.
Thanks to these features, this framework is nowadays the base of many embedded systems developed in Rust.

\subsection{async/await}
\label{subsec:async}
Async/await is a concurrency model utilizing cooperative tasks.
Cooperative tasks are tasks that yield control back to the scheduler at determined points\cite{aparicio_concurrency_nodate} and these points are when task switching occurs.
Tasks can yield for example to wait for a blocking operation.

This concurrency model may prove extremely useful for embedded systems as it allows for concurrent code to be written in an imperative way, which increases code readability.
Imagine a device driver task that resumes its operation when new data is received, but doesn't use any blocking waits and the code can be read as an sequence of operations instead of for example a state machine.

Async/await in the Rust programming language builds upon the \textbf{Future} trait.
A future can be polled and polling results in reporting whether the \textbf{Future} can resume executing or not.
An executor takes care of periodically (or as an reaction to an event) polling \textbf{Futures} and resumes their execution if needed.
Given the design of async/await, this can be easily used in a \textbf{no\_std} environment, even on low computing power devices, such as the Atmel AVR\cite{schattinger_asyncawait_2020}.
As of now there are several async runtimes for embedded systems, the most advanced one being \textbf{embassy}, the downside being that it currently requires nightly Rust to build.

An example of utilizing async/await for timed tasks and \textbf{embassy} can be seen in the Listing~\ref{lst:embassy}

\begin{lstlisting}[caption={Timed tasks using async/await and embassy\cite{noauthor_embassy-rsembassy_2021}.},label=lst:embassy]
#[embassy::task]
async fn run1() {
    loop {
        info!("BIG INFREQUENT TICK");
        Timer::after(Duration::from_ticks(64000)).await;
    }
}

#[embassy::task]
async fn run2() {
    loop {
        info!("tick");
        Timer::after(Duration::from_ticks(13000)).await;
    }
}

#[embassy::main]
async fn main(spawner: Spawner) {
    unwrap!(spawner.spawn(run1()));
    unwrap!(spawner.spawn(run2()));
}
\end{lstlisting}

\subsection{Ecosystem}
\label{subsec:ecosystem}
The Embedded Rust ecosystem is nowadays very vast.
Apart from the Embedded Devices Working Group, there are many smaller organizations governing development for specific platforms or projects.
There are organization and groups developing crates for \acs{mcu} support (STM32, RISC-V, AVR, RP2040, iMXrt, SAMD etc.), universal device drivers (using the embedded-hal described earlier) and much more.
The ecosystem also consists of tooling and documentation, which is also under active development, with some tools surpassing traditional tools for embedded development.
More importantly, given Rust's focus on performance and security, eliminating most common bugs, the developers are able to work on the "harder" problems in embedded - for example drivers for USB\cite{noauthor_stm32-rsstm32-usbd_2021} or Ethernet\cite{noauthor_stm32-rsstm32-eth_2021}.

\subsection{C/C++ Interoperability}
\label{subsec:ccpp_interop}
Thanks to Rust's \acs{ffi} (\acl{ffi}), it is possible to combine code written in C and Rust, even both ways\cite{rust_embedded_devices_wg_interoperability_nodate}.
For example, it is possible to utilize Rust's serialization and deserialization crates in an existing Zephyr project\cite{wolff_embedding_nodate}.
This is especially useful for bringing Rust into existing embedded codebase, but also for integrating existing C/C++ codebase into new Rust project.

\subsection{Tooling}
\label{subsec:tooling}
% knurling

\subsection{Testing and CI}
\label{subsec:testing_ci}

\section{Why We Believe Embedded Rust Is the Right Choice}
\label{sec:embedded_rust_reasoning}